# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UPwhI3VWazN5eMuGm9kxJ08piDtVDP_V
"""

pip install streamlit
import streamlit as st
import pandas as pd
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import LabelEncoder
import joblib
import pickle
import os

def load_model_and_encoders():
    # Attempt to load the pre-trained model and fitted encoders from the pickle file
    model_path = 'car.pkl'
    data_path = 'car_price_prediction.csv'

    if not os.path.exists(model_path):
        st.error(f"{model_path} not found. Please ensure the model file is in the same directory.")
        st.error("If car.pkl does not exist, you need to train and save the model first.")
        return None # Return None to indicate failure

    try:
        with open(model_path,'rb') as file:
            model, le_brand, le_model, le_fuel = pickle.load(file)
    except Exception as e:
        st.error(f"Error loading model from {model_path}: {e}")
        return None # Return None to indicate failure

    # Load the data for dropdown options
    if not os.path.exists(data_path):
        st.error(f"{data_path} not found. Please ensure the data file is in the same directory.")
        return None # Return None to indicate failure

    try:
        price_df = pd.read_csv(data_path) # Assign directly to price_df
    except Exception as e:
        st.error(f"Error loading data from {data_path}: {e}")
        return None # Return None to indicate failure

    # If everything loads successfully, return the objects
    return model, le_brand, le_model, le_fuel, price_df

# Load model, encoders, and data
# Check if the loading was successful before attempting to unpack
loaded_assets = load_model_and_encoders()

if loaded_assets is None:
    st.stop() # Stop the Streamlit app if loading failed
else:
    # Unpack the assets if loading was successful
    model, le_brand, le_model, le_fuel, price_df = loaded_assets

    st.title("ðŸš— Car Price Prediction App")

    # Dropdown options
    # Use the inverse_transform from the loaded encoders
    # Ensure the columns exist before attempting to access them
    if 'Brand' in price_df.columns and 'Model' in price_df.columns and 'Fuel Type' in price_df.columns:
        brand_names = sorted(le_brand.inverse_transform(price_df['Brand'].unique()))
        model_names = sorted(le_model.inverse_transform(price_df['Model'].unique()))
        fuel_names = sorted(le_fuel.inverse_transform(price_df['Fuel Type'].unique()))
    else:
         st.error("Required columns (Brand, Model, Fuel Type) not found in the data file.")
         st.stop()


    # User inputs
    brand = st.selectbox("Select Brand", brand_names)
    model_name = st.selectbox("Select Model", model_names)
    fuel_type = st.selectbox("Select Fuel Type", fuel_names)

    year = st.number_input("Enter Manufacturing Year", min_value=1990, max_value=2025, value=2015)
    mileage = st.number_input("Enter Mileage (in km)", min_value=0.0, step=100.0)
    engine_size = st.number_input("Enter Engine Size (in cc)", min_value=500.0, step=100.0)

    # Predict button
    if st.button("Predict Price"):
        try:
            # Encode the user inputs using the loaded encoders
            encoded_brand = le_brand.transform([brand])[0]
            encoded_model = le_model.transform([model_name])[0]
            encoded_fuel = le_fuel.transform([fuel_type])[0]

            features = [[
                encoded_brand,
                encoded_model,
                year,
                encoded_fuel,
                mileage,
                engine_size
            ]]

            # Use the loaded model for prediction
            predicted_price = model.predict(features)[0]
            st.success(f"ðŸ’° Predicted Price: ${predicted_price:,.2f}")
        except Exception as e:
            st.error(f"Error during prediction: {e}")
